'''На языке Python реализовать функцию, которая быстрее всего (по процессорным
тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со
случайным порядком чисел (в том числе и отсортированным). Объяснить почему вы
считаете, что функция соответствует заданным критериям.'''


def get_sorted_array(arr):
    return sorted(arr)

# Так как в задании нет ограничений на используемые инструменты, то самым
# очевидным решением видится использование встроенной сортировки (TimSort).
# Данный метод хорошо себя зарекомендовал и используется по-умолчанию не только
# в Python, но и в Java и других языках. Так как задание допускает разный
# порядок чисел (включая отсортированный), то Timsort в ряде случаев будет
# существенно эффективнее своих конкурентов (Magnus Lie Hetland. Python
# Algorithms: Mastering Basic Algorithms in the Python Language). Кроме того,
# TimSort реализован на более низкоуровневом языке чем Python, что также даёт
# ему преимущество перед написанными на самом Python алгоритмами.

# Если всё-таки попробовать реализовать логику алгоритма самостоятельно, то
# я бы выбрал Merge sort как быструю и подходящую для самых разных массивов
# сортировку. Реализовать Merge sort можно, например, так:


def mergesort(arr):
    if len(arr) in (0, 1):
        return arr

    arr_0 = mergesort(arr[:len(arr) // 2])
    arr_1 = mergesort(arr[len(arr) // 2:])

    merger = [0] * (len(arr_0) + len(arr_1))
    i_0, i_1, i_m = 0, 0, 0
    while i_0 < len(arr_0) and i_1 < len(arr_1):
        if arr_0[i_0] <= arr_1[i_1]:
            merger[i_m] = arr_0[i_0]
            i_0 += 1
        else:
            merger[i_m] = arr_1[i_1]
            i_1 += 1
        i_m += 1
    while i_0 < len(arr_0):
        merger[i_m] = arr_0[i_0]
        i_0 += 1
        i_m += 1
    while i_1 < len(arr_1):
        merger[i_m] = arr_1[i_1]
        i_1 += 1
        i_m += 1
    arr = merger[:]
    return arr
